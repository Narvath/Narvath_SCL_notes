Les processus classiques ont ont quelques inconvénients:
- Gestion lourde par recopie pour créer de nouveaux processus
- Gaspille de la mémoire
- Perd du temps a exécuter le code séquentiellement

## Qu'est-ce qu'un thread?
Un thread de contrôle représente le chemin d'exécution.
Lorsqu'un SE offre la possibilité d'associer à un même processus plusieurs chemins d'exécution on a du multithreading.
- Un thread est une unité d'exécution rattachée à un processus, chargée d'exécuter une partie du programme du processus.
- Pour un processus ses threads (fils d'exécution) partagent l’ensemble de ses ressources (espace d’adressage, fichiers, …)
- Un processus léger (thread) est par nomination plus léger à gérer et sa gestion peut être personnalisée.
- Lorsqu’un processus est créé, un seul fil d’exécution (thread) est associé au processus
	- Le thread principal exécutant la fonction main du programme du processus. 
	- Ce fil principal peut en créer d’autres.
	- États uniques pour chaque processus léger, chaque fil a: 
		- un identificateur unique,
		- une pile d'exécution,
		- des registres (un compteur ordinal) ,
		- priorité…

- Chaque thread a sa propre [[Processus#^8fa366|pile]] en mémoire 
## Qu'est-ce que ça fait?
- Plusieurs activités ont lieu simultanément (plusieurs tâches dans l'app peuvent être implémentés par des threads séparés.)
- Meilleure performances
	- **Réactivité**: (le processus peut continuer à s’exécuter même si certaines de ses parties sont bloquées), particulièrement importante pour les interfaces utilisateur
	- **Partage de ressources**: les threads partagent des ressources de processus, plus faciles pour le programmeur que la mémoire partagée ou les mécanismes de passage de message (facilite la coopération, améliore les performances)
	- **Économie d’espace mémoire et de temps**: Il faut moins de temps pour: 
		- créer, terminer un thread (sous Solaris, la création d’un processus est 30 fois plus lente que celle d’un thread),
		- changer de contexte entre deux threads d’un même processus.
	- **Scalabilité** : peut tirer parti des architectures multiprocesseurs

## [[Processus#^e0ccf8|PCB]] vs TCB (Thread Control Block)
![[PCB vs TCB.png]]
## Concurrence : 
Un seul cœur, illusion de parallélisme
## Parallélisme : 
Peut effectuer plusieurs taches simultanément. Chaque cœur du processeur peuvent avoir un thread actif à la fois.
### Types de parallélisme:
**Des données :** Distribue des sous-ensembles des mêmes données sur plusieurs cœurs, la même opération sur chaque
**Des Taches :** Distribution des threads à travers les cœurs, chaque thread effectuant une opération unique

## États d'un thread
- bloqué
- en cours d’exécution
- en attente d’exécution
## Librairie de thread
Les threads parent-enfant peuvent être
- synchrone: le thread parent doit attendre la fin de tous les threads enfants 
	- par exemple, partage des données et combinaison des résultats 
- asynchrone: le parent poursuit son exécution,
	- souvent le cas pour les services de type serveur
### Librairie POSIX
Fonctions de base : 
- pthread_create    Crée un nouveau thread 
- pthread_join        Attend la fin d’un thread 
- pthread_exit        Termine le thread appelant 
- pthread_yield       Libère le CPU pour d’autres thread