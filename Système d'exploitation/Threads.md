Les processus classiques ont ont quelques inconvénients:
- Gestion lourde par recopie pour créer de nouveaux processus
- Gaspille de la mémoire
- Perd du temps a exécuter le code séquentiellement

## Qu'est-ce qu'un thread?
Un thread de contrôle représente le chemin d'exécution.
Lorsqu'un SE offre la possibilité d'associer à un même processus plusieurs chemins d'exécution on a du multithreading.
- Un thread est une unité d'exécution rattachée à un processus, chargée d'exécuter une partie du programme du processus.
- Pour un processus ses threads (fils d'exécution) partagent l’ensemble de ses ressources (espace d’adressage, fichiers, …)
- Un processus léger (thread) est par nomination plus léger à gérer et sa gestion peut être personnalisée.
- Lorsqu’un processus est créé, un seul fil d’exécution (thread) est associé au processus
	- Le thread principal exécutant la fonction main du programme du processus. 
	- Ce fil principal peut en créer d’autres.
	- États uniques pour chaque processus léger, chaque fil a: 
		- un identificateur unique,
		- une pile d'exécution,
		- des registres (un compteur ordinal) ,
		- priorité…

- Chaque thread a sa propre [[Processus#^8fa366|pile]] en mémoire 
## Qu'est-ce que ça fait?
- Plusieurs activités ont lieu simultanément (plusieurs tâches dans l'app peuvent être implémentés par des threads séparés.)
- Meilleure performances
	- **Réactivité**: (le processus peut continuer à s’exécuter même si certaines de ses parties sont bloquées), particulièrement importante pour les interfaces utilisateur
	- **Partage de ressources**: les threads partagent des ressources de processus, plus faciles pour le programmeur que la mémoire partagée ou les mécanismes de passage de message (facilite la coopération, améliore les performances)
	- **Économie d’espace mémoire et de temps**: Il faut moins de temps pour: 
		- créer, terminer un thread (sous Solaris, la création d’un processus est 30 fois plus lente que celle d’un thread),
		- changer de contexte entre deux threads d’un même processus.
	- **Scalabilité** : peut tirer parti des architectures multiprocesseurs

## [[Processus#^e0ccf8|PCB]] vs TCB (Thread Control Block)
![[PCB vs TCB.png]]
## Concurrence : 
Un seul cœur, illusion de parallélisme
## Parallélisme : 
Peut effectuer plusieurs taches simultanément. Chaque cœur du processeur peuvent avoir un thread actif à la fois.
### Types de parallélisme:
**Des données :** Distribue des sous-ensembles des mêmes données sur plusieurs cœurs, la même opération sur chaque
**Des Taches :** Distribution des threads à travers les cœurs, chaque thread effectuant une opération unique

## États d'un thread
- bloqué
- en cours d’exécution
- en attente d’exécution
## Librairie de thread
Les threads parent-enfant peuvent être
- synchrone: le thread parent doit attendre la fin de tous les threads enfants 
	- par exemple, partage des données et combinaison des résultats 
- asynchrone: le parent poursuit son exécution,
	- souvent le cas pour les services de type serveur
### Librairie POSIX
Fonctions de base : 
- pthread_create    Crée un nouveau thread 
- pthread_join        Attend la fin d’un thread 
- pthread_exit        Termine le thread appelant 
- pthread_yield       Libère le CPU pour d’autres thread

## Création & exécution d'un thread
Si un main (thread) boucle pour créer plusieurs thread enfants, ceux-cis ne vont pas nécessairement s'exécuter dans l'ordre dans lequel ils ont été créés.

Si le pthread_join est implémenté après la boucle, le main les threads vont être tous créés avant d'être exécutés.
```cpp
void *print_hello(void *tnum) { 
	printf(“Bonjour je suis le thread %d\n”,*(int*)tnum); 
	pthread_exit(NULL); 
	} 
	int main(int argc, char *argv[]) { 
	// Le programme cree N_THREADS threads et se termine 
	pthread_t threads[N_THREADS]; 
	int status, i, Arg[N_THREADS]; 
	for (i=0; i < N_THREADS; i++) { 
		Arg[i] = i; 
		printf(“Main(): en train de creer thread %d\n”,i); 
		status = pthread_create(&threads[i], NULL, print_hello, (void *)&Arg[i]); 
		if (status != 0) { 
			printf(“oops, pthread a retourne le code d’erreur %d\n”,status); 
			exit(-1); 
		} 
	} 
	// Attendre la fin des threads 
	for (i=0; i < N_THREADS; i++) { pthread_join(threads[i], NULL); } 
	exit(NULL); 
}
```

Si le pthread_join est implémenté dans la boucle, le main va attendre l'exécution de chaque thread avant de créer le prochain.
```cpp
void *print_hello(void *tnum) { 
	printf(“Bonjour je suis le thread %d\n”,*(int*)tnum); 
	pthread_exit(NULL); 
	} 
	int main(int argc, char *argv[]) { 
	// Le programme cree N_THREADS threads et se termine 
	pthread_t threads[N_THREADS]; 
	int status, i, Arg[N_THREADS]; 
	for (i=0; i < N_THREADS; i++) { 
		Arg[i] = i; 
		printf(“Main(): en train de creer thread %d\n”,i); 
		status = pthread_create(&threads[i], NULL, print_hello, (void *)&Arg[i]); 
		if (status != 0) { 
			printf(“oops, pthread a retourne le code d’erreur %d\n”,status); 
			exit(-1); 
		}
		pthread_join(threads[i], NULL); 
	} 
	exit(NULL); 
}
```

## Modèles de threads 
### Utilisateur **
- Les threads sont implémentés dans des libraires indépendantes du système d’exploitation
- Le processus doit avoir du code spécialisé pour la gestion des threads
- Les TCB (Thread Control Block) sont enregistrés dans la mémoire de chaque processus
- Le noyau ne sait rien des threads, c’est le processus qui s’en occupe
- Basculement explicite entre chaque thread. Par exemple en utilisant une fonction de type yield()
- Plus efficace, car pas besoin de passer par le noyau car moins d’appels système
- Chaque processus peut avoir son propre algorithme d’ordonnancement

**Problèmes**
- Difficile d'implémenter parfaitement
- Doit détecter les appels bloquants
- Difficile de garder la préemption (administration)
	- Le noyau ne peut pas interrompre un thread spécifiquement
	- Si le processus bloque, tous les threads bloquent aussi
### Noyau **
- À la connaissance des threads donc préemption (administration) du thread en cours et détecte les appels systèmes bloquants
- Le noyau peut choisir le prochain thread à exécuter dans le même processus ou dans un autre processus
- pthreads sont des threads noyau

**Problèmes**
- Création d’un thread implique un appel système
- Noyau va créer une entrée dans table des threads 
- Coût plus élevé que thread utilisateur
- Changement de thread passe par un appel système (couteux)
### Modèle Hybride **
Essayer d’avoir le meilleur des deux mondes, un thread noyau exécute un certain nombre de thread utilisateur mais implémentation robuste encore plus difficile à atteindre. Il y a donc une relation (modèle) entre les threads utilisateur et les threads du noyau.
#### Modèle Many-to-One
- De nombreux threads de niveau utilisateur associés à un thread de noyau unique.
- Un blocage de thread (par exemple, exécuter une requête E / S) provoque le blocage de tous.
- Les threads ne peuvent pas s'exécuter en parallèle sur un système multicœur car un seul peut accéder au noyau à la fois.
#### Modèle One-to-One
- Chaque thread de niveau utilisateur correspond a un thread du noyau 
- La création d'un thread de niveau utilisateur crée un thread de noyau 
- Le nombre de threads par processus est limité en raison des threads du noyau
#### Modèle Many-To-Many
- Permet à de nombreux threads de niveau utilisateur d'être mappés vers de nombreux threads du noyau (M-N)
- Permet au système d'exploitation de créer un nombre suffisant de threads du noyau, en fonction de sa configuration matérielle, mais donne la possibilité à l'utilisateur de créer autant de threads utilisateur que souhaité

#### Modèle à deux niveaux
Similaire à Many-to-Many, sauf qu'il permet également à un thread utilisateur d'être lié à un thread du noyau