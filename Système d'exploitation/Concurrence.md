## Communication inter-processus
On cherche des moyens de transmettre de l'information entre processus.
Une solution est d'avoir un emplacement de mémoire partagée (RAM). 
Une autre est d'avoir un Tube (pipe) directement entre deux processus, l'un write() et l'autre read(). C'est unidirectionnel et utilise une FIFO.

Partager un système de stockage comme un fichier ou une mémoire partagée peut causer problème si deux processus tentent d'y accéder en même temps.

## Critères à respecter pour le partage de données
**Exclusion mutuelle :** 
2 processus ne peuvent pas être dans la section critique en même temps

**Pas d'interblocage :**
Aucun processus ne doit bloquer les autres à l’entrée de leur section critique s’il est hors de sa section critique

**Pas de famine :**
Aucun processus ne doit attendre indéfiniment pour entrer dans la section critique

**Aucune hypothèse :**
Pas de supposition sur le temps d’exécution ou le nombre de CPU (oui, mais ça n’arrivera pas… » bang!)

## Solutions aux problèmes de concurrence
1. Désactiver les interruptions
2. Utiliser une variable de verrou
	1. Peut ne pas fonctionner!
Des solutions meh

### Solutions par Verrou pivotant (spinlock) (attente active)
Consomme du CPU car busy waiting.
Peut être efficace SI le blocage est court, car ne force pas un changement de contexte. Souvent utilisé dans les noyaux.

Cela cause problème s'il y a une inversion de priorité (s'il y a deux processus avec des priorités différentes). Par exemple, si le processus prioritaire H débute, arrête d'utiliser du CPU par lui-même, l'ordonnanceur va démarrer le processus a priorité basse (L). Si celui-ci rentre en zone critique et que le processus H redevient prêt, l'ordonnanceur va lui redonner la priorité et celui-ci va boucler infiniment dans l'attente active car L est dans la zone critique.
#### Peterson (logiciel)**
Solution purement logicielle qui utilise les variables globales waiting et critical.
On va venir entourer la section critique pour contrôler l’accès et s’identifier avant d’y entrer.
#### TSL
Solution avec de l'aide matérielle TSL, EAX et LOCK
Valeur non nulle dans LOCK lorsqu'il y a écriture en mémoire, 0 lorsque libre.

**Étapes du fonctionnement**
1. En entrant on copie LOCK dans le registre EAX, LOCK = 1
2. Compare le registre EAX avec #0 (LOCK == 0)
3. SI non Boucle à nouveau la vérification
4. Si oui, rentre dans la région critique, fait ce qu'il a à faire puis écrit 0 dans LOCK.

Encore du busy waiting (spinlock)
#### XCHG
Même chose que TSL sauf qu'on peut écrire autre chose que 0/1 dans LOCK, plus générique.

### Solutions sans busy waiting
### Producteur-consommateur
