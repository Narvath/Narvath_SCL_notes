## Communication inter-processus
On cherche des moyens de transmettre de l'information entre processus.
Une solution est d'avoir un emplacement de mémoire partagée (RAM). 
Une autre est d'avoir un Tube (pipe) directement entre deux processus, l'un write() et l'autre read(). C'est unidirectionnel et utilise une FIFO.

Partager un système de stockage comme un fichier ou une mémoire partagée peut causer problème si deux processus tentent d'y accéder en même temps.

## Critères à respecter pour le partage de données
**Exclusion mutuelle :** 
2 processus ne peuvent pas être dans la section critique en même temps

**Pas d'interblocage :**
Aucun processus ne doit bloquer les autres à l’entrée de leur section critique s’il est hors de sa section critique

**Pas de famine :**
Aucun processus ne doit attendre indéfiniment pour entrer dans la section critique

**Aucune hypothèse :**
Pas de supposition sur le temps d’exécution ou le nombre de CPU (oui, mais ça n’arrivera pas… » bang!)

## Solutions aux problèmes de concurrence
1. Désactiver les interruptions
2. Utiliser une variable de verrou
	1. Peut ne pas fonctionner!
Des solutions meh

### Solutions par Verrou pivotant (spinlock) (attente active)
Rapide, mais consomme du CPU car busy waiting.
Peut être efficace SI le blocage est court, car ne force pas un changement de contexte. Souvent utilisé dans les noyaux.

Cela cause problème s'il y a une inversion de priorité (s'il y a deux processus avec des priorités différentes). Par exemple, si le processus prioritaire H débute, arrête d'utiliser du CPU par lui-même, l'ordonnanceur va démarrer le processus a priorité basse (L). Si celui-ci rentre en zone critique et que le processus H redevient prêt, l'ordonnanceur va lui redonner la priorité et celui-ci va boucler infiniment dans l'attente active car L est dans la zone critique.
#### Peterson (logiciel)**
Solution purement logicielle qui utilise les variables globales waiting et critical.
On va venir entourer la section critique pour contrôler l’accès et s’identifier avant d’y entrer.
#### TSL
Solution avec de l'aide matérielle TSL, EAX et LOCK
Valeur non nulle dans LOCK lorsqu'il y a écriture en mémoire, 0 lorsque libre.

**Étapes du fonctionnement**
1. En entrant on copie LOCK dans le registre EAX, LOCK = 1
2. Compare le registre EAX avec #0 (LOCK == 0)
3. SI non Boucle à nouveau la vérification
4. Si oui, rentre dans la région critique, fait ce qu'il a à faire puis écrit 0 dans LOCK.

Encore du busy waiting (spinlock)
#### XCHG
Même chose que TSL sauf qu'on peut écrire autre chose que 0/1 dans LOCK, plus générique.

### Solutions sans busy waiting
#### Producteur-consommateur
La problématique est que si le producteur demande au consommateur de se réveiller pour consommer un item et que celui-ci n'était pas encore en sleep (allait ou était en train d'exécuter le sleep) alors le signal de 'réveil' est perdu. Le consommateur être comme en 'veille' et le producteur va remplir le tableau d'items. 

On règle le problème avec des sémaphores (variables). On vérifie la valeur de la variable au lieu de caller le producteur/consommateur directement

Un mutex est très semblable a un sémaphore binaire, sauf que seulement le propriétaire du mutex peut le libérer. Sémaphore binaire est donc moins robuste.

POSIX est une interface standard pour les mutex sur UNIX.
pthread_mutex_init           Crée un nouveau mutex 
pthread_mutex_destroy    Détruit un mutex 
pthread_mutex_lock          Verrouille un mutex ou bloque 
pthread_mutex_trylock      Verrouille un mutex ou ne bloque pas 
pthread_mutex_unlock      Déverrouille un mutex

Règle le problème d'inversion de priorité.
Thread bloqué, mais perd son tour avec CPU.
#### Approche hybride synchronisation
Utile seulement si multicoeur.
Spinlock up peu si le thread possédant le mutex est en cours d'exécution, bloque après.
## Barrières
Pour synchroniser un groupe de threads ensemble.
pthread_barrier_init           Crée une barrière 
pthread_barrier_destroy    Détruit une barrière 
pthread_barrier_wait          Attend à une barrière

## Variables de conditions
Rappel:
**Sémaphores :** permet a K threads d'accéder à une ressource.
**Mutex :** Permet de limiter l'accès aux zones critiques.

Variables de conditions:
Pour qu’un thread se bloque, le temps qu’une condition soit remplie. Par exemple, attendre qu’un buffer ne soit pas vide.
*Toujours utilisées à l’intérieur d’une section critique protégée par un mutex*
Signal qu'une condition sur une variable globale est remplie.
À besoin d'un mutex pour fonctionner.
plus générales que des sémaphores qui sont seulement des ints de 0 ou 1.

C'est un mécanisme pour endormir et réveiller les threads
C'est une façon d'éviter de faire de l'attente active (spinlock)