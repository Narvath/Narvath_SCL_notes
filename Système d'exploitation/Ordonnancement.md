L'ordonnanceur sélectionne les processus/thread à exécuter dans la liste de ceux qui sont prêts.

Le type choisi va affecter le temps de réponse, l'expérience ressentie par l'utilisateur ainsi que la capacité de traitement (quantité de travail effectif par unité de temps)

On veut maximiser l'utilisation des composantes du système. 
On essaie d'être équitable, on veux que chaque processus ait accès au même temps de calcul en moyenne et qu'il n'y ait pas de famine.

### Il n'y a pas d'ordonnanceur parfait
**Traitement par lot :** a un très long quantum (200ms ish), bonne capacité de traitement (débit)
**Interactifs :** quantum de 5-20ms. Compromis entre temps de réponse et débit.
**Temps réel :** QNX ajustable jusqu'à 40 us, temps de réponse et prédictibilité.

## Changement de processus
Le coût généralement:
- lorsqu'il faut basculer du mode utilisateur/noyau,
- premier changement de contexte
- changer l',espace d'adressage
- Calcul d'ordonnancement
## Quand faire l'ordonnancement?
Quand un processus fait un appel système:
- Fork
- Exit
- Bloque sur E/S, mutex, condition
- Est libéré d'un mutex
- yield()
Quand il y a une interruption
- Sur E/S déplace les processus en état bloqué vers prêt
- sur l'horloge

## Interruption sur l'horloge
Un intervalle de temps entre deux interruptions d'horloge est nommé quantum.
L'ordonnanceur sera lancé lorsqu'un quantum expire.
Approximativement entre 5 et 20 ms sur les PC.
Interruption permet d'exécuter d'autres processus même si celui en cours est dans une boucle sans fin.

## Algorithmes d'ordonnancement
### Premier arrivé, premier servi
- L'ordre d'exécution dépends de l'ordre d'arrivée
- Une seule file d'attente
- Si un process bloque, on exécute le prochain
-  Quand process débloque il retourne à la fin de la file
- Pas de préemption
#### Avantages
- Facile à comprendre / implémenter
- Efficace, car peu de changements de contexte
- Pas de famine
#### Défaut
- Pas optimal pour le temps moyen d'attente
- Puni les processus qui font beaucoup d' E/S (si replacé à la fin de la file)
- Très mauvais temps de réponse
### Job le plus court en premier
On suppose qu'on connait le temps d'exécution nécessaire pour les processus.
Pas de préemption, on fini la job qu'on à avant de vérifier quelle est la plus court suivante à exécuter.
### Temps restant le plus court
PRÉEMPTIF
Risque de famine pour les process les plus long.
Interruption à l'arrivée d'un nouveau processus pour réévaluer lequel est le plus court.
### Tourniquet (round robin)
Très utilisé car:
- Simple
- Relativement équitable
- sert de base pour d'autres algorithmes
Chaque processus reçoit un quanta de temps.
Exécute le process pendant le quanta de temps puis s'il n'est pas terminé le renvoie à la fin de la liste.

## Priorité
Les processus ont des priorités. À ce moment la, chaque niveau de priorité a une file. Va tourniquetter sur chaque file.

## Completely Fair Scheduler
