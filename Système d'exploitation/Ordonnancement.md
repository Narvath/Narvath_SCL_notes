L'ordonnanceur sélectionne les processus/thread à exécuter dans la liste de ceux qui sont prêts.

Le type choisi va affecter le temps de réponse, l'expérience ressentie par l'utilisateur ainsi que la capacité de traitement (quantité de travail effectif par unité de temps)

On veut maximiser l'utilisation des composantes du système. 
On essaie d'être équitable, on veux que chaque processus ait accès au même temps de calcul en moyenne et qu'il n'y ait pas de famine.

### Il n'y a pas d'ordonnanceur parfait
**Traitement par lot :** a un très long quantum (200ms ish), bonne capacité de traitement (débit)
**Interactifs :** quantum de 5-20ms. Compromis entre temps de réponse et débit.
**Temps réel :** QNX ajustable jusqu'à 40 us, temps de réponse et prédictibilité.

## Changement de processus
Le coût généralement:
- lorsqu'il faut basculer du mode utilisateur/noyau,
- premier changement de contexte
- changer l',espace d'adressage
- Calcul d'ordonnancement
## Quand faire l'ordonnancement?
Quand un processus fait un appel système:
- Fork
- Exit
- Bloque sur E/S, mutex, condition
- Est libéré d'un mutex
- yield()
Quand il y a une interruption
- Sur E/S déplace les processus en état bloqué vers prêt
- sur l'horloge

## Interruption sur l'horloge
Un intervalle de temps entre deux interruptions d'horloge est nommé quantum.
L'ordonnanceur sera lancé lorsqu'un quantum expire.
Approximativement entre 5 et 20 ms sur les PC.
Interruption permet d'exécuter d'autres processus même si celui en cours est dans une boucle sans fin.

## Algorithmes d'ordonnancement
### Premier arrivé, premier servi
- L'ordre d'exécution dépends de l'ordre d'arrivée
- Une seule file d'attente
- Si un process bloque, on exécute le prochain
-  Quand process débloque il retourne à la fin de la file
- Pas de préemption
#### Avantages
- Facile à comprendre / implémenter
- Efficace, car peu de changements de contexte
- Pas de famine
#### Défaut
- Pas optimal pour le temps moyen d'attente
- Puni les processus qui font beaucoup d' E/S (si replacé à la fin de la file)
- Très mauvais temps de réponse
### Job le plus court en premier
On suppose qu'on connait le temps d'exécution nécessaire pour les processus.
Pas de préemption, on fini la job qu'on à avant de vérifier quelle est la plus court suivante à exécuter.
### Temps restant le plus court
PRÉEMPTIF
Risque de famine pour les process les plus long.
Interruption à l'arrivée d'un nouveau processus pour réévaluer lequel est le plus court.
### Tourniquet (round robin)
Très utilisé car:
- Simple
- Relativement équitable
- sert de base pour d'autres algorithmes
Chaque processus reçoit un quanta de temps.
Exécute le process pendant le quanta de temps puis s'il n'est pas terminé le renvoie à la fin de la liste.

## Priorité
Les processus ont des priorités. À ce moment la, chaque niveau de priorité a une file. Va tourniquetter sur chaque file.

## Ordonnanceurs Linux
Il y a trois façons de faire:
### SCHED_FIFO
Temps réel, Pas de préemption a moins qu'il y ait l'ajout d'une priorité plus haute. Exécute les processus des files plus prioritaire en premier, puis les autres.
### SCHED__RR
Temps réel, peut être préempté et timeslice.
Possèdent un quantum
Tourniquet par niveau de priorité
### SCHED_NORMAL
Pour les threads normaux, lorsqu'il n'y a plus rien dans SCHED_FIFO et SCHED_RR.
Fonctionne par Epoch (liste). Exécute les process avec le plus haut niveau de priorité comme un tourniquet en utilisant des quanta (x ms dépendament de la priorité) puis les déplace dans le prochain epoch s'ils ne sont pas terminés. Si terminé, vas dans 'expiré'.
Pour indiquer au S.E. qu’on veut céder son tour on utilise sched_yield(). va placer à la fin de la fille. (mets dans la fie expirée)
#### Priorité statique
Le niveau de priorité statique varie entre -20 et 10
Par défaut, p_statique = 0
Plus que c'est petit plus que c'est pressant
P_statique est ajusté avec **nice** et **setpriority()**
#### Priorité dynamique
P_dynamique est ajusté automatiquement par le S.E. Il va punir les processus gourmand en CPU (rafale de processus longs) et récompenser les petits.
Basé dur des heuristiques.
C'est calculé à partir du temps qu'un thread passe bloqué, plus il bloque longtemps plus son P_dynamique augmente. Cela ne s'applique pas aux autres SCHED.

P_Sched (Normal) = 120 + P_statique + P_dynamique
Doit donc rester entre 100 et 139
Les autres SCHED sont en bas de 100.

Le temps de calcul alloué aux processus est 
( 140 - p_sched (SP) +- NICE ) * 20 si SP < 120
( 140 - p_sched (SP) +- NICE ) * 5 si SP >= 120
### Completely Fair Scheduler
Cherche à simuler un processeur parfait.
offrir 1/N du processeur aux N processus, mais aussi en tenant compte de leur priorité! Aussi, juste entre les différents utilisateurs : 
Utilisateur A : 48 processus niveau 120 
Utilisateur B : 2 processus niveau 120
Pour chaque niveau de priorité, on associe un poids w
Poids w plus élevé : droit à plus de temps processeur
Tperiod : période pendant laquelle on voudrait idéalement faire tourner chacun des N threads une fois